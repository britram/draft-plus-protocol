<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY I-D.ietf-taps-transports SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-taps-transports.xml">
]>


<rfc ipr="trust200902" docName="draft-hildebrand-plus-protocol" category="std">

  <front>
    <title abbrev="plus-protocol">PLUS Protocol</title>

    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization>Cisco Systems</organization>
      <address>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>

    <date year="2016" month="August" day="02"/>

    
    
    

    <abstract>


<t>Minimal in-band firewall and load balancer signaling for UDP.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<section anchor="terms" title="Terms">

<t><list style="symbols">
  <t>Initiator: The program initiating the protocol exchange.  Often thought of
as the “client” in a client-server protocol.</t>
  <t>Responder: The program receiving the initiation request.  Often thought of
as the “server” in a client-server protocol.</t>
  <t>Transport’ protocol: the layer inside PLUS that is providing semantics
such as those described in <xref target="I-D.ietf-taps-transports"/>.</t>
</list></t>

</section>
<section anchor="requirements" title="Requirements">

<t><list style="symbols">
  <t>Hint to Initiator’s network path that PLUS is likely in use</t>
  <t>Hint to Initiator’s network path that Initiator wants to initiate a new
connection</t>
  <t>Further indication to path that PLUS protocol is in use when Responder’s
messages are seen by the path, better than 5-tuple.</t>
  <t>Matching Responder’s packets to Initiator’s intent to communicate, better
than 5-tuple</t>
</list></t>

</section>
</section>
<section anchor="protocol" title="Protocol">

<section anchor="initiator_bits" title="Bit pattern: Initiator">

<figure><artwork><![CDATA[
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       magic = 0xd80000d8                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                               |R|R|           |
|                Conection ID                   |S|S|   tflags  |
|                                               |T|V|           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The following bits are defined:</t>

<t><list style="symbols">
  <t>Magic Constant, 32 bits</t>
  <t>Connection ID, 24 bits</t>
  <t>RST, 1 bit: Reset</t>
  <t>RSV, 1bits: reserved for future use in this protocol</t>
  <t>tflags: 6 bits: available for use in the next layer</t>
</list></t>

<t>More about the magic number, how it was found, how you could generate new
ones.  The magic number is also effectively a version number for this layer.</t>

</section>
<section anchor="responder_bits" title="Bit pattern: Responder">

<figure><artwork><![CDATA[
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                               |R|R|           |
|                        hmac                   |S|S|   tflags  |
|                                               |T|V|           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The following bits are defined:</t>

<t><list style="symbols">
  <t>hmac, 24 bits: HMAC_SHA256(magic, ConnectionID), truncated</t>
  <t>RST, 1 bit: Reset</t>
  <t>RSV, 1bits: reserved for future use in this protocol</t>
  <t>tflags: 6 bits: available for use in the next layer</t>
</list></t>

</section>
<section anchor="indication-of-implementation" title="Indication of implementation">

<t>The receiver performs HMAC_256(0xd80000d8, ConnectionID), and uses the
first 3 bytes as the first 3 bytes of the reply.  This is used as a further
hint that the magic number use was intentional.  Call this function
Indicator(ConnectionID).</t>

<t>Usefully, none of these truncated HMACs return the magic number.</t>

</section>
</section>
<section anchor="processing" title="Processing">

<t>Basic idea: Initiator sends bits defined in <xref target="initiator_bits"/>, Responder
sends bits defined in <xref target="responder_bits"/>.  Initiator always has to send first
over every new path.</t>

<section anchor="processing-by-applications" title="Processing by applications">

<t><list style="symbols">
  <t>If the RSV bit is set, ignore the packet</t>
  <t>Initiator: If the hmac doesn’t match what you expect, it’s either an attack
or leftover traffic from a previous connection.  Maybe send an unsigned RST?
(maybe this is a policy or transport-specific decision)</t>
  <t>Responder: If the magic number isn’t there, it’s likely an attack.  Probably
best to ignore it.</t>
</list></t>

</section>
<section anchor="processing-by-path-elements" title="Processing by path elements">

<t><list style="symbols">
  <t>Assume that all bits are protected by next layer, so you can’t change them.
Even if you could change them, you may as well just drop the packet, since
delivery won’t work.</t>
  <t>Don’t think that having RSV set means this is an attack.  It’s just
something we haven’t specified as of the time you wrote your code.</t>
</list></t>

</section>
<section anchor="from-inside-to-outside" title="From inside to outside:">

<t><list style="symbols">
  <t>Match magic number
  <list style="symbols">
      <t>If not, treat as non-PLUS UDP; use port for example</t>
    </list></t>
  <t>Forward 6tuple = 5tuple + ConnectionID</t>
  <t>Reverse 6tuple = Reverse 5tuple + Indicator(ConnectionID)</t>
  <t>Look up Forward
  <list style="symbols">
      <t>If not, create state keyed by Forward and Reverse</t>
    </list></t>
  <t>Reset timer
  <list style="symbols">
      <t>When timer fires, either drop state or send RST hint both ways without
e2e crypto</t>
    </list></t>
  <t>Allow</t>
</list></t>

</section>
<section anchor="from-outside-to-inside" title="From outside to inside:">

<t><list style="symbols">
  <t>Look up Reverse, allow if match
  <list style="symbols">
      <t>If not, treat as non-PLUS UDP</t>
    </list></t>
</list></t>

<t>(TODO: determine if reverse timer is useful)</t>

</section>
</section>
<section anchor="guidelines-for-next-layer" title="Guidelines for next layer">

<t>New transport’ protocols like QUIC.</t>

<t><list style="symbols">
  <t>Define tflags as you see fit</t>
  <t>Consider if these bits need protection.  At least tflags do.</t>
  <t>Consider multipath consequences, send before you receive on each path, and
consider using a different ConnectionID on different paths to make tracking
harder.  If so, figure out how load balancers are going to deal with the
problem.</t>
</list></t>

</section>
<section anchor="security" title="Security Considerations">

<t>Next layer transport protocols SHOULD discuss whether any of these bits need
to be protected.</t>

<t>Discuss the actual number of bits that window tracking gives you for TCP.
Contrast this with how useful this would be for tracking people.</t>

<t>ConnectionID’s MUST NOT be under the control of untrusted code, like
JavaScript.  It’s likely there’s a reason for making them not available to
untrusted code as well.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>Do we need a registry of magic numbers?</t>

</section>


  </middle>

  <back>


    <references title='Informative References'>

&I-D.ietf-taps-transports;


    </references>



  </back>
</rfc>

